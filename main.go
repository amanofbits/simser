// Copyright 2023 am4n0w4r
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"flag"
	"fmt"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"strings"
)

func getFlags() (outputFile string, rawTypes string) {
	flag.StringVar(&rawTypes, "types", "", "comma-separated struct types to use")
	flag.StringVar(&outputFile, "output", "",
		"name of output file")

	flag.Parse()

	return outputFile, rawTypes
}

func main() {
	targetFile := os.Getenv("GOFILE")

	outputFile, rawTypes := getFlags()
	if outputFile == "" {
		outputFile = fmt.Sprintf("%s.simser.g.go", strings.TrimSuffix(targetFile, ".go"))
	}

	f, typesInfo, err := analyzeInput(targetFile)
	if err != nil {
		log.Fatal(err)
	}

	typs, err := selectTypes(f, getTypenames(rawTypes))
	if err != nil {
		log.Fatal(err)
	}

	for i := 0; i < len(typs); i++ {
		if err := appendFieldInfos(&typs[i], typesInfo); err != nil {
			log.Fatal(err)
		}
	}

	output := newOutput(f.Name.Name, typesInfo)

	output.addFileComment(fmt.Sprintf(
		"// Code generated by \"%s %s\"; DO NOT EDIT.", filepath.Base(os.Args[0]), strings.Join(os.Args[1:], " ")))

	if err := generateFunctions(typs, output); err != nil {
		log.Fatal(err)
	}

	if err := writeOutputFile(output, outputFile); err != nil {
		log.Fatal(err)
	}
}

func writeOutputFile(output *outputFile, filename string) error {

	outFile, err := os.Create(filename)
	if err != nil {
		return fmt.Errorf("failed to create output file, %w", err)
	}
	defer outFile.Close()

	if _, err := output.write(outFile); err != nil {
		return fmt.Errorf("failed to write outpput file, %w", err)
	}
	log.Printf("file %s written", filename)
	return nil
}

func getTypenames(rawTypes string) (typenames map[string]any) {
	typenames = map[string]any{}

	switch rawTypes {
	case "":
		log.Fatalf("use '-types' flag to set input types")
	case "all":
		typenames["all"] = 0
	default:
		for _, t := range strings.Split(rawTypes, ",") {
			typenames[t] = 0
		}
	}
	return typenames
}

func appendFieldInfos(sInfo *structInfo, typesInfo *types.Info) error {

	sInfo.fields = []fieldInfo{}
	for _, f := range sInfo.typ.Fields.List {
		fInfo, err := getFieldInfo(f, typesInfo)
		if err != nil {
			return err
		}
		for _, name := range f.Names {
			copy := fInfo
			copy.name = name.Name
			sInfo.fields = append(sInfo.fields, copy)
		}
	}
	return nil
}
